10/13
DSU : Decorate-Sort-Undecorate
lambda 이름 없는 함수


10/17
Selection 문제
n개의 숫자들 중에서 k번째로 작은 숫자를 찾는 문제
퀵 정렬에 있던 파티션을 활용, 파티션 함수를 그대로 사용가능하다

small group 피봇보다 작은 숫자 그룹
large group 피봇보다 큰 숫자 그룹

small group에 k번째로 작은 숫자가 있다면
small group에서 k번째로 작은 숫자를 찾는다.
large group에 k번째로 작은 숫자가 있다면
large group에서 (k - size(small group) - 1)번째로 작은 숫자를 찾는다. -1 은 피봇 값 제외

분할정복이면서 랜덤 알고리즘이기도 하다.
-> 피봇을 랜덤하게 선택하기 때문에
피봇의 입력을 너무 한쪽으로 치우치게 분할하면 알고리즘 수행 시간이 길어진다.

평균 경우 시간 복잡도 O(n)

중앙값을 찾는데 활용


최급접 점의 쌍 찾기 문제 (Closest Pair Problem)
2차원 평면상의 n개의 점이 입력으로 주어질 때, 거리가 가장 가까운 한 쌍의 점을 찾는 문제
간단한 방법 - brute force 화면상에 모든 점들의 거리를 각각 계산해서 비교 O(n^2)
분할 정복 이용 - 그룹을 나누어서 각각의 그룹에서 최단 거리를 찾고, 그 중에서 가장 짧은 거리를 찾는다.
-> 취합할 때 중간 영역을 고려해야된다.

공간의 점을 x-좌표로 정렬 : O(nlogn)
스트립을 위한 점을 y-좌표로 정렬 : O(nlog)
시간 복잡도 : O(nlog^2n)(스트립을 매번 정렬하는 경우)
-> 미리 y-좌표로 정렬해 놓은 배열을 만들어서 사용하면 매번 정렬하지 않아도 된다.
-> y-좌표로 정렬해놓은 배열에서 뽑아 오면 되기 때문에 O(n)이 된다.
=> 최종 시간 복잡도 O(nlogn)


10/20
퀵 정렬의 최악 경우 시간 복잡도는 O(n^2)이지만 피벗 선정에 많이 노력을 들여
보통 O(nlogn)의 시간 복잡도를 가진다고 말한다.

분할 정복은 문제를 분할 했을 때 각각의 문제가 원래의 문제보다 작아야 한다.
또한 취합하는 과정에서 문제가 없는지 확인해야 한다.


10/24
시험
1장
알고리즘 - 문제를 해결하기 위한 단계적인 절차
왜 - 문제
무엇을 - 요구사항 분석, 해야하는 일/ 안해도 되는 일 구분
어떻게 - 알고리즘 계발
언제 - 프로젝트 매니저의 역할

알고리즘 = 요리법과 유사
경험이 있는 사람이 효과적인 알고리즘을 선택해야 된다

최대 숫자 찾기
 - 순차 탐색(Sequential Search)
    n개의 자료가 있을 때 n를 모두 확인
-이진 탐색(Binary Search)
    이미 정렬이 되어있다면 사용 가능
    절반씩 나누어 가면서 탐색

동전 거스름돈 문제
그리디 방식으로 해결(동전이 그렇게 구성되어있기 때문에)
그리디 방식 - 가장 큰 액면의 동전을 한도에서(욕심 내어) 최대한 많이 선택

한붓그리기 조건
가능한 경우 - 짝수개인 점만 있을 때
홀수 점 4개 이상이면 불가능
한붓그리기 알고리즘
한 개만 남았다면 그 점으로
2개 이상이 남을 경우 현재점으로 돌아오는 사이클이 있는 점으로 이동

미로 찾기
back-tracking 방식 - 모든 경우의 수를 모두 찾아보는 방법
오른손 법칙 - 오른손(또는 왼손)으로 벽을 집고 이동, 벽을 펼치면 하나의 선이 될 것이다.
    벽의 일부분이 섬이되어 있다면 해결 할 수 없음

가짜 동전 찾기
알고리즘에 따른 시간 차이를 보여줌
1. 동전 하나 놓고 하나씩 바꾸는
2. 두 개씩 올리고 바꾸는
3. 반 씩 올리는

1. n번 비교 
2. n/2번 비교
-> 둘의 big-O 표현은 O(n)으로 같지만 실제로는 2가 빠름
-> 무한대로 n이 커지면 증가하는 시간 속도가 비슷한
3. log n번 비교 반드시 1번보다 빠르지는 않음, 하지만 평균적으로 빠름
-> log3 n, 동전을 세 덩이로 나누면 log2 n 보다 빠름

독이 든 술단지
100개의 술단지 중 하나 독 - 7명의 신하만 있으면 찾을 수 있음
술단지 번호를 2진수로 표현해서 비트별로 먹어보면 됨

2장
알고리즘의 특성
정확성 - 올바른 해
수행성 - 컴퓨터에서 수행 가능
유한성 - 유한 시간 내에 종료
효율성 - 효율적일 수록 가치가 높음

유클리드의 최대 공약수 알고리즘 - 최초의 알고리즘
2개의 자연수의 최대공약수는 큰 수에서 작은 수를 뺸 수와 작은 수와의 최대공약수는 같다.
뺄셈 대신 나눗셈을 적절히 사용하면 빠르게 구할 수 있다

1~n까지의 덧셈
여러가지 공식을 활용할 수 있다.

아키텍트가 알고리즘을 표현해주는 방법
자연어(보통말)를 사용
플로우 차트를 그림
의사 코드로 표현 - 실제 코딩은 코더가, 문법을 따지지 않고 표현, 프로그래밍 언어에서 몇가지 단어를 선택해서 사용
    -> 더 간단하게 표현 가능

알고리즘 분류
분할정복
그리디
동적 계획
근사
백트래킹
분기 한정

알고리즘의 효율성 - 수행 시간, 사용되는 메모리의 크기
-> 시간 복잡도, 공간 복잡도
주로 시간 복잡도를 사용
(카운트 정렬에 경우에는 공간 복잡도가 중요할 수 있음)

시간 복잡도
n개의 자료가 있을 떄 n의 대한 식으로 표현
최악 경우, 평균 경우, 최선 경우롤 분류
최악의 경우를 가지고 이야기 하는 경우가 많음

시간 복잡도의 점근적 표기
big-O 점근적 상한
big-omega 점근적 하한
big-theta 상한과 하한을 모두 만족
표기는 o로 하지만 보통 theta의 내용을 가진다

다항식에서 최고 차수 항만을 취하고 그 항의 계수를 제거하여 표현

O(1) 상수 (시간)
O(log n) 로그
O(n) 선형
nlogn 로그 선형 -> 보통 일반적으로 빠르다고 말하는 알고리즘
n^2 이차 -> 이 이상되면 일반적으로 느린 알고리즘
n^3 3차
n^k 다항식, k는 상수
2^n 지수
//순서 잘 보기

위에 있는 것이 아래 있는 것보다 반드시 빠른것은 아님
힙 정렬 vs 쉘 소트
50만개 까지는 쉘이 더 빠름 -> 그렇다고 쉘 소트가 빠르다고 말할 수 없음

n0 속도가 연적되는 값은 알고리즘에 따라 당겨지기도 밀리기도 함

하드웨어 강화 < 알고리즘 개선 -> 더 싸게 먹힘

의사코드 - 아이디어를 전달하기 위해 사용
퀵 소트를 최악의 경우 n^2 이지만 평균적으로 nlogn으로 가기 때문에 그렇게 부름

6장
내부 정렬 - 주기억 장치 안에서
외부 정렬 - 입력의 크기가 주기억 장치 공간보다 큰 경우

내부 정렬 알고리즘 표(위키백과 그 짤)
퀵소트는 안정한 정렬이 아니다
버블과 삽입은 같은 n이지만 삽입은 그 특성 떄문에 실전에서 사용
gcc sort 퀵 소트
gcc stable sort 합볍 정렬

버블 정렬 - 인접한 것 끼리 변경하면서 반복
최선의 경우 O(n)
구현하기 쉽다는 장점(직접 구현하는 것보다 언어에서 제공하는 정렬을 확실히 사용할 줄 알아야)
최악의 경우 O(n^2)

선택 정렬 - 최소값을 선택에서 왼쪽으로 보냄
입력에 민감하지 않음 -> 항상 일정한 시간 복잡도
원소 간의 자리바꿈 휫수가 최소인 정렬

삽입 정렬 - 정렬 안된 부분에서 하나를 골라서(주인공) 정렬된 부분에 삽입(이중 루프)
이중루프를 돌기 때문에 O(n^2) 알고리즘
어느정도 정렬이 된 데이터가 들어온다면 O(n^2)이 아니게됨, n에 가까운 알고리즘이 됨
어느정도 정렬된 데이터에 대해 다른 알고리즘보다 빠른 성능
삽입 정렬 과정 잘 이해, 구현할 수도 있어야함
이미 정렬된 입력 -> O(n)의 시간 복잡도

일력에 크기가 작을 때 좋은건 거의 모든 O(n^2) 알고리즘이 동일

합병 정렬이나 퀵 정렬의 입력 크기가 작아지면 순환 호출을 중단하고 삽입 정렬 사용
Tim sort 합병 정렬 - 입력 크기가 64 이하면 삽입 정렬 사용

쉘 정렬
갭의 개념을 둬서 갭 만큼 뛰어서 이동
갭에 따라서 어떤식으로 정렬이 수행되는지 이해 해야됨
3중 루프로 구현
1. 갭 차이 줄여가면서 결국 1이 되도록
2. 주인공 선택(갭 신경 안쓰고 갭 크기만큼의 인덱스부터 쭉 삽입정렬 진행)
3. 삽입 정렬
시간 복잡도는 정확히 알려지지 않음
    히바드의 간격 = O(n^1.5)

힙 정렬
힙 조건을 만족하는 완전 이진 트리
힙 조건 : 각 노드의 우선 순위가 자식 노드의 우선 순위보다 높다
최대 힙 : 가장 큰 값이 루트에 저장
최소 힙 : 가장 작은 값이 루트에 저장 

n개의 노드가 있는 이진 트리의 높이 - log2 n
루트 노드가 인덱스 0인지 1인지에 따라서 구현이 살짝 달라짐

1. 정렬할 입력을 힙 상태로 만든다
2. 루트에 있는 것을 뺴고 다시 힙 상태로 만든다

DownHeap() 
루트로부터 자식들 중에서 큰 값을 가진 자식과 비교하여 힙 속성이 만족될 때까지 숫자를 교환하며 이파리 방향으로 진행
전체 노드의 절반의 개수의 노드만 자식을 가짐
전체의 절반부터 DownHeap() -> 최초로 힙 만드는 시간이 O(nlogn)이 아니고 O(n)이다.

힙 정렬의 시간 복잡도 = O(nlogn)
단점 - 많은 캐시 미스로 인한 페이지 부재를 야기시킴

결정 트리
n! 만큼의 이파리가 만들어짐, 높이 log(n!)
log(n!) = O(nlogn)
nlogn 보다 빠른 비교 정렬은 없다

카운트 정렬
비교 정렬보다 빠름, 메모리를 너무 많이 사용할 가능성이 있음
정렬의 대상의 가짓수(r)가 적을 때 주로 사용
O(n+r) r이 n보다 현저히 적다면 O(n)

가짓수를 나누어서 정렬 -> 기수 정렬(Radix Sort)
기(Radix)는 특정 진수를 나타내는 숫자들 (2진수 0, 1 / 10진수 0, 1, 2, ..., 9)
입력 : n개의 r진수의 k자리 숫자
O(k(n+r))의 시간 복잡도 -> k나 r이 n에 비해 현저히 작은 숫자이면 O(n)

LSD - 작은 숫자부터 안정한 정렬을 사용(카운트 정렬을 이용)
MSD - 큰 숫자부터(분할 정복에 가까운 방식)

for-루프가 k번 반복
    O(n+r) 소요

크기가 일정한 것으 정렬하는데 효과적인 정렬

3장 분할정복
주어진 문제를 분할하여 문제를 해결하고 취합하는 방법
퀵 정렬, 이진 탐색, 선택 문제 알고리즘, 삽입 정렬, 피보나치 수열(분할 정복에 어울리지 않음)

합병 정렬
1. 왼쪽 합병 정렬
2. 오른쪽 합병 정렬
3. 왼쪽, 오른쪽 합병
시간 복잡도 O(nlogn), 공간 복잡도 O(n) (합병할 때 필요한 메모리)

퀵 정렬
분할된 문제를 합치지 않음(정복 후 분할)
피봇을 잘 결정해서 파티션을 나눔
피봇보다 큰 수 오른쪽으로
작은 수는 왼쪽으로 

1. 파티션
2. 왼쪽 퀵 소트
3. 오른쪽 퀵 소트

퀵 소트 최악의 경우 O(n^2) - 피봇 선택이 안좋아서 하나씩만 분할되면
정확히 반씩 나누어지면 최선의 경우 - O(nlogn)

피봇 선정 방법
랜덤
median of three
median of medians
최대한 절반씩 나눌 수 있도록 시간을 투자

선택 문제
피봇 설정은 퀵 소트랑 같음
찾고자 하는 값이 피봇 기준으로 왼쪽인지 오른쪽인지 확인해서 찾아감
좋은 분할을 해야됨(절반에 가까운 분할)
시간 복잡도 O(n)
퀵과 공통점 - 취합하는 과정이 필요없음, 피봇에 따라 나눠지는 크기가 다름
이진과 차이점 - 이진은 항상 반으로 나눠짐

최근접 점의 쌍 찾기 문제
x 좌표로 정렬하고 인덱스로 반으로 갈라서 최단 거리 찾음
분할했기 때문에 비교하지 못한 중간 영역을 합병할 때 비교해야함(중간 영역에 더 짧은 점이 있는지 확인)
중간 영역을 비교할 때 y좌표로 미리 정렬된 값을 사용

각층의 수행시간 O(n)
층 수 logn
최종 시간 복잡도 O(nlogn)

피보나치 수
분할하면 문제의 수가 오히려 더 늘어남

분할 정복에선 취합(정복)할 때 문제가 없는지 잘 확인해야함

퀵 소트에 경우만 유일한게 평균의 경우를 알고리즘의 속도로 말함(보통의 경우 최악의 시간 복잡도로 표현)
